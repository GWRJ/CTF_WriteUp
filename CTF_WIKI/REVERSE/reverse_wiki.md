# PlzDebugMe CTF 逆向工程 WriteUp

## 题目信息

* **题目名称**: PlzDebugMe
* **题目类型**: 逆向工程 (Reverse Engineering)
* **难度**: 入门级
* **文件**: 235737\_PlzDebugMe.exe

## 1. 题目分析

### 1.1 初步观察

这是一个典型的入门级逆向工程题目。从题目名称"PlzDebugMe"可以推测，这道题需要我们通过调试或静态分析来找出隐藏的flag。

### 1.2 工具准备

对于逆向工程，我们需要准备以下工具：

* **IDA Pro** 或 **Ghidra**: 静态反汇编分析工具
* **x64dbg** 或 **OllyDbg**: 动态调试工具
* **十六进制编辑器**: 如HxD、010 Editor
* **字符串提取工具**: 如strings命令

## 2. 静态分析过程

### 2.1 使用IDA Pro分析

将exe文件拖入IDA Pro，等待自动分析完成。

#### 寻找main函数

1. 查看函数列表，寻找可能的主函数
2. 找到关键函数 `sub_401697()`，这很可能是主要的验证逻辑

#### 反汇编代码分析

```c
int sub_401697()
{
  int i; // [esp+1Ch] [ebp-4h]
  sub_401860();
  sub_40160C("WeLcome to Reverse World!\n");
  sub_40160C("Length of the flag is 32.\n");
  sub_40160C("Please enter your flag:\n");
  sub_4015D0("%s", byte_415060);
  if ( byte_415060[0] == 102    // 'f'
    && byte_415061 == 108       // 'l'
    && byte_415062 == 97        // 'a'
    && byte_415063 == 103       // 'g'
    && byte_415064 == 123       // '{'
    && byte_41507F == 125 )     // '}'
  {
    sub_401648(123456);
    for ( i = 0; i <= 31; ++i )
    {
      byte_415060[i] = sub_40167D((unsigned __int8)byte_415060[i]);
      if ( byte_415060[i] != byte_410020[i] )
      {
        sub_40160C("Pity! Wrong flag!\n");
        return 0;
      }
    }
    sub_40160C("Congratulations! You get the flag!\n");
    return 0;
  }
  else
  {
    sub_40160C("WRONG\n");
    return 0;
  }
}
```

### 2.2 程序逻辑分析

#### 第一层检查：格式验证

```c
if ( byte_415060[0] == 102    // 'f'
  && byte_415061 == 108       // 'l'
  && byte_415062 == 97        // 'a'
  && byte_415063 == 103       // 'g'
  && byte_415064 == 123       // '{'
  && byte_41507F == 125 )     // '}'
```

**分析要点**：

* 程序首先检查输入是否以 `flag{` 开头
* 检查第31个字符（索引31，因为数组从0开始）是否为 `}`
* 说明flag格式为: `flag{...内容...}`，总长度32位

#### 第二层检查：加密验证

```c
sub_401648(123456);  // 初始化某种算法
for ( i = 0; i <= 31; ++i )
{
  byte_415060[i] = sub_40167D((unsigned __int8)byte_415060[i]);
  if ( byte_415060[i] != byte_410020[i] )  // 与目标数组比较
  {
    // 验证失败
  }
}
```

**分析要点**：

* `sub_401648(123456)` 看起来像是初始化函数，参数123456可能是种子
* `sub_40167D` 是对每个字符进行某种变换
* 变换后的结果与 `byte_410020` 数组进行比较

### 2.3 深入分析关键函数

#### sub\_401648函数分析

```c
int __cdecl sub_401648(int a1)
{
  int result; // eax
  result = a1;
  dword_415080 = a1;  // 将参数存储到全局变量
  return result;
}
```

这个函数很简单，就是把参数123456存储到全局变量 `dword_415080` 中。

#### sub\_40167D函数分析

```c
int __cdecl sub_40167D(unsigned __int8 a1)
{
  return (unsigned __int8)sub_401656() ^ a1;  // XOR加密
}
```

这是一个XOR加密函数，将输入字符与 `sub_401656()` 的返回值进行异或操作。

#### sub\_401656函数分析（关键！）

```c
unsigned int sub_401656()
{
  dword_415080 = 1103515245 * dword_415080 + 12345;
  return HIWORD(dword_415080) & 0x7FFF;
}
```

**重要发现**：

* 这是一个**线性同余生成器 (Linear Congruential Generator, LCG)**
* 公式：`next = (a * seed + c) mod m`
* 这里 a=1103515245, c=12345, m=2^32（32位整数溢出）
* 返回值是高16位的低15位：`(seed >> 16) & 0x7FFF`

### 2.4 获取目标数据

在IDA中查看 `byte_410020` 地址的数据：

```
地址 410020 处的32字节数据：
5B 50 A1 25 84 8E 61 C4 6B BB AE 05 0B C6 3D 42
5A FB C1 C9 4E E9 8D 50 91 87 87 24 AD AF D5 36
```

## 3. 加密算法理解

### 3.1 完整的加密流程

1. **初始化**：设置LCG种子为123456
2. **对每个字符**：
   * 调用LCG生成下一个伪随机数
   * 取随机数的低8位
   * 与字符进行XOR运算
3. **比较**：将加密结果与目标数组比较

### 3.2 LCG算法详解

线性同余生成器是一种常见的伪随机数生成算法：

```
seed[n+1] = (a × seed[n] + c) mod m

其中：
- a = 1103515245 (乘数)
- c = 12345 (增量)  
- m = 2^32 (模数，通过32位整数溢出实现)
- seed[0] = 123456 (初始种子)
```

**为什么这样设计？**

* LCG算法简单，在CTF中经常使用
* 只要知道参数和种子，就能完全重现随机数序列
* 这就给了我们破解的可能性

## 4. 解密方案

### 4.1 解密思路

既然我们知道了：

1. 加密算法（XOR + LCG）
2. LCG的参数 (a=1103515245, c=12345, seed=123456)
3. 加密后的目标数据

那么我们可以：

1. 重现相同的LCG随机数序列
2. 将目标数据与随机数进行XOR，得到原始字符

### 4.2 XOR的性质

XOR运算有一个重要性质：**可逆性**

* 如果 `A XOR B = C`
* 那么 `C XOR B = A`

所以如果我们知道：

* 原文 XOR 随机数 = 密文
* 那么：密文 XOR 随机数 = 原文

### 4.3 Python解密脚本

```python
def lcg_next(seed):
    """线性同余生成器"""
    seed = (seed * 1103515245 + 12345) & 0xFFFFFFFF
    return seed, (seed >> 16) & 0x7FFF

def decrypt_flag():
    # 目标加密数据
    encrypted = [
        0x5B, 0x50, 0xA1, 0x25, 0x84, 0x8E, 0x61, 0xC4,
        0x6B, 0xBB, 0xAE, 0x05, 0x0B, 0xC6, 0x3D, 0x42,
        0x5A, 0xFB, 0xC1, 0xC9, 0x4E, 0xE9, 0x8D, 0x50,
        0x91, 0x87, 0x87, 0x24, 0xAD, 0xAF, 0xD5, 0x36
    ]
  
    seed = 123456
    flag = []
  
    for i in range(32):
        seed, random_val = lcg_next(seed)
        decrypted_char = encrypted[i] ^ (random_val & 0xFF)
        flag.append(chr(decrypted_char))
  
    return ''.join(flag)
```

## 5. 逆向工程技术总结

### 5.1 这道题涉及的知识点

1. **静态分析**：使用反汇编工具分析程序结构
2. **伪随机数生成器**：理解LCG算法原理
3. **XOR加密**：了解异或运算的性质
4. **数据提取**：从程序中提取关键数据
5. **算法逆向**：从加密过程推导解密方法

### 5.2 解题思路总结

1. **理解程序逻辑**：分析main函数，找到验证流程
2. **识别加密算法**：分析关键函数，理解加密方式
3. **提取关键数据**：获取加密参数和目标数据
4. **设计解密方案**：利用算法的可逆性质
5. **编写解密工具**：实现自动化解密

### 5.3 常见的逆向分析模式

#### 字符串比较型

* 直接比较输入与预设字符串
* 解法：直接提取目标字符串

#### 简单变换型

* 对输入进行简单的数学运算（加减乘除、位运算）
* 解法：逆向数学运算

#### 伪随机加密型（本题类型）

* 使用伪随机数生成器进行加密
* 解法：重现随机数序列，逆向加密过程

#### 复杂加密算法型

* 使用标准加密算法（AES、DES等）
* 解法：找到密钥，使用对应解密算法

## 6. 学习建议

### 6.1 对于RE新手

1. **掌握基础工具**：
   * 学会使用IDA Pro/Ghidra进行静态分析
   * 学会使用调试器进行动态分析
2. **理解常见算法**：
   * 各种伪随机数生成器
   * 基础加密算法（XOR、Caesar等）
   * 常见的字符串处理方法
3. **培养逆向思维**：
   * 从结果推导过程
   * 理解程序的执行流程
   * 学会抽象和简化问题

### 6.2 进阶学习路径

1. **汇编语言基础**：理解x86/x64汇编
2. **加密学基础**：了解各种加密算法
3. **反调试技术**：学习如何绕过程序的保护机制
4. **脱壳技术**：处理被加壳保护的程序

### 6.3 实践建议

1. 多做CTF题目，从简单到复杂
2. 阅读优秀的writeup，学习他人的思路
3. 学习使用各种逆向工程工具
4. 关注安全社区，了解最新技术

## 7. 总结

这道 PlzDebugMe 题目虽然标记为"超级简单"，但实际上涉及了逆向工程的多个重要概念：

1. **静态分析技能**：使用IDA Pro分析程序结构
2. **算法识别能力**：识别出LCG伪随机数生成器
3. **密码学基础**：理解XOR加密的可逆性
4. **编程实现**：将分析结果转化为可执行的解密代码

对于逆向工程初学者来说，这是一道很好的入门题目，它展现了逆向分析的完整流程：观察→分析→理解→实现。通过这道题目，可以学习到逆向工程的基本思维模式和常用技术手段。

记住逆向工程的核心：**理解程序想要什么，然后给它想要的**。在这道题中，程序想要的是经过特定算法加密后的字符串，我们通过逆向这个算法，成功找到了原始的flag。



# PlzDebugMe 动态调试完整攻略 - 新手向

## 🎯 学习目标

通过本教程，你将学会：

1. 使用x64dbg进行动态调试
2. 理解程序执行流程
3. 在内存中找到关键数据
4. 不需要复杂的算法分析就能获取flag

## 🛠️ 工具准备

### 推荐工具：x64dbg

* **下载地址**：https://x64dbg.com/
* **优点**：界面友好、功能强大、完全免费
* **支持**：32位和64位程序

### 备选工具：OllyDbg

* **版本**：OllyDbg 1.10（32位程序）或 OllyDbg 2.01（支持64位）
* **特点**：经典调试器，很多CTF选手的首选

## 📋 动态调试基础知识

### 什么是动态调试？

* **静态分析**：不运行程序，只看代码结构
* **动态调试**：运行程序，观察执行过程中的内存、寄存器变化

### 为什么要动态调试？

1. **直观**：能看到程序实际执行过程
2. **简单**：不需要深入理解算法细节
3. **准确**：避免静态分析的推测错误
4. **快速**：对于简单加密，可以直接获取结果

## 🚀 动态调试实战 - x64dbg篇

### Step 1: 加载程序

1. **启动x64dbg**
   * 根据程序位数选择x32dbg或x64dbg
   * PlzDebugMe.exe是32位程序，选择x32dbg
2. **加载目标程序**
   ```
   File → Open → 选择 235737_PlzDebugMe.exe
   ```
3. **界面介绍**
   ```
   ┌─────────────┬─────────────┬─────────────┐
   │  反汇编窗口   │   寄存器窗口   │   内存窗口    │
   │ (Assembly)  │ (Registers) │  (Memory)   │
   ├─────────────┼─────────────┼─────────────┤
   │   栈窗口     │   断点窗口    │   日志窗口    │
   │  (Stack)   │(Breakpoints)│   (Log)     │
   └─────────────┴─────────────┴─────────────┘
   ```

### Step 2: 找到关键函数

#### 方法1：通过字符串定位

1. **右键反汇编窗口** → **Search for** → **All modules** → **String references**
2. **搜索关键字符串**：
   ```
   "WeLcome to Reverse World!""Length of the flag is 32""Please enter your flag"
   ```
3. **双击找到的字符串**，跳转到使用该字符串的代码位置

#### 方法2：通过函数入口定位

1. **按Ctrl+G**，输入程序入口点（通常是main函数附近）
2. **单步执行**，找到主要逻辑

### Step 3: 设置关键断点

#### 断点位置1：输入处理后

找到类似这样的代码：

```assembly
call    401530                ; scanf("%s", buffer)
```

**在这行之后设置断点**：

* 点击行号左侧设置断点（红点）
* 或按F2键

#### 断点位置2：比较循环

找到验证循环的位置：

```assembly
mov     al, [esi+ecx]         ; 读取加密后的字符
cmp     al, [410020+ecx]      ; 与目标数组比较
jnz     loc_fail              ; 不相等则跳转失败
```

**在比较指令处设置断点**

### Step 4: 运行到断点

1. **按F9开始运行**程序
2. **程序会提示输入flag**，输入测试内容：

   ```
   flag{AAAAAAAAAAAAAAAAAAAAAAAA}
   ```

   (确保总长度32位，以flag{开头，}结尾)
3. **程序在断点处暂停**

### Step 5: 观察内存数据

#### 查看输入缓冲区

1. **在内存窗口中**，按Ctrl+G
2. **输入地址**：`415060`（这是存储输入的缓冲区）
3. **观察**：你会看到刚才输入的flag内容

#### 查看目标数组

1. **在内存窗口中**，按Ctrl+G
2. **输入地址**：`410020`
3. **重要**：这里显示的就是我们需要匹配的目标数据！

```
地址 410020: 5B 50 A1 25 84 8E 61 C4 6B BB AE 05 0B C6 3D 42
地址 410030: 5A FB C1 C9 4E E9 8D 50 91 87 87 24 AD AF D5 36
```

### Step 6: 获取随机数序列

#### 方法1：单步跟踪（推荐新手）

1. **找到比较循环**
2. **在每次比较前观察寄存器**：
   * 输入字符通常在AL寄存器
   * 经过加密变换后，观察AL的值变化

#### 方法2：内存断点监控

1. **右键内存窗口** → **Set breakpoint** → **Memory on access**
2. **选择410020地址范围**，监控访问
3. **每次访问时记录随机数值**

### Step 7: 提取关键数据 (新手友好方法)

#### 最简单的方法：修改内存直接获取flag

1. **在比较循环的断点处**：
   ```assembly
   mov     al, [esi+ecx]         ; AL = 加密后的输入字符
   cmp     al, [410020+ecx]      ; 与目标值比较
   ```
2. **记录每一轮的数据**：
   * ECX寄存器：当前位置索引 (0-31)
   * AL寄存器：加密后的输入字符
   * `[410020+ecx]`：目标值
3. **获取随机数**：
   * 随机数 = AL ⊕ 输入字符
   * 例如：输入'A'(0x41)，AL=0x1A，则随机数=0x1A⊕0x41=0x5B

#### 更简单的方法：让程序告诉我们答案

**技巧：修改比较结果**

1. **在比较指令处**：`cmp al, [410020+ecx]`
2. **手动修改AL寄存器的值**，让它等于目标值
3. **记录每次修改的值**，这就是我们需要的加密后数据
4. **用这些数据推导出原始flag**

## 🎮 动态调试实战 - OllyDbg篇

### 基本操作类似x64dbg

#### 加载程序

```
File → Open → 选择exe文件
```

#### 界面布局

```
┌──────────────────┬──────────────────┐
│    反汇编窗口      │    寄存器窗口      │
├──────────────────┼──────────────────┤
│    内存转储窗口    │      栈窗口       │
└──────────────────┴──────────────────┘
```

#### 关键快捷键

* **F2**: 设置/取消断点
* **F7**: 单步步入 (Step Into)
* **F8**: 单步步过 (Step Over)
* **F9**: 运行 (Run)
* **Ctrl+G**: 跳转到地址

### OllyDbg特色功能

#### 字符串搜索

```
右键反汇编窗口 → Search for → All referenced text strings
```

#### 内存搜索

```
右键内存窗口 → Search → Binary string
```

## 🔍 动态调试解题完整流程

### 方案A：直接内存提取法（最适合新手）

#### Step 1: 程序分析

1. **运行程序**，了解基本输入输出
2. **设置断点**在字符串提示之后
3. **找到存储目标数据的内存地址**

#### Step 2: 数据提取

1. **找到地址410020**，这里存储了32字节的目标数据
2. **复制这32字节**：
   ```
   5B 50 A1 25 84 8E 61 C4 6B BB AE 05 0B C6 3D 425A FB C1 C9 4E E9 8D 50 91 87 87 24 AD AF D5 36
   ```

#### Step 3: 随机数获取

1. **输入测试flag**：`flag{AAAAAAAAAAAAAAAAAAAAAAAA}`
2. **在比较循环中设置断点**
3. **记录每轮比较的数据**：
   ```
   位置0: 输入'f', 加密后=?, 目标=0x5B → 随机数=目标⊕'f'位置1: 输入'l', 加密后=?, 目标=0x50 → 随机数=目标⊕'l'...
   ```

#### Step 4: flag计算

使用XOR的可逆性：

```
原字符 ⊕ 随机数 = 加密字符
加密字符 ⊕ 随机数 = 原字符
目标字符 ⊕ 随机数 = flag字符
```

### 方案B：脚本辅助法

#### 在调试器中使用简单脚本

**x64dbg脚本示例**：

```javascript
// x64dbg脚本：自动提取目标数据
var targetAddr = 0x410020;
var result = "";
for(var i = 0; i < 32; i++) {
    var byte = Debug.ReadByte(targetAddr + i);
    result += byte.toString(16).padStart(2, '0').toUpperCase() + " ";
}
log("Target data: " + result);
```

## 💡 动态调试技巧总结

### 新手常用技巧

#### 1. 内存数据直接查看

* **不需要理解复杂算法**
* **直接在内存中找到目标数据**
* **适用于大部分简单CTF题目**

#### 2. 断点策略

```
输入断点 → 了解输入存储位置
处理断点 → 观察数据变换过程  
比较断点 → 获取目标数据
输出断点 → 验证结果
```

#### 3. 寄存器监控

* **EAX/AL**: 通常存储函数返回值或当前处理的字符
* **ECX**: 常用作循环计数器
* **ESI/EDI**: 常指向源/目标缓冲区

### 进阶技巧

#### 1. 条件断点

```
只在特定条件下断下：
ECX == 5  (只在处理第6个字符时断下)
AL != 0x41  (只在AL不等于'A'时断下)
```

#### 2. 内存断点

```
监控特定内存地址的读写：
Memory breakpoint on 0x410020 (读取时断下)
Memory breakpoint on 0x415060 (写入时断下)
```

#### 3. 日志断点

```
不停止执行，只记录信息：
log "Position: " + ECX + ", Value: " + AL
```

## 📝 动态调试解题模板

### 标准流程检查清单

```
□ 1. 加载程序并找到main函数
□ 2. 搜索关键字符串定位验证逻辑
□ 3. 在输入处理后设置断点
□ 4. 输入测试数据并运行到断点
□ 5. 找到目标数据存储位置
□ 6. 在比较循环中设置断点
□ 7. 记录比较过程中的关键数据
□ 8. 分析加密算法或直接逆推
□ 9. 构造正确的flag
□ 10. 验证结果
```

### 常见问题解决

#### 程序有反调试怎么办？

1. **检查IsDebuggerPresent调用**
2. **使用插件绕过反调试**
3. **修改检测函数的返回值**

#### 找不到关键函数怎么办？

1. **搜索错误信息字符串**："Wrong", "Correct"等
2. **API断点**：在printf、scanf等函数下断点
3. **入口点分析**：从程序入口开始单步跟踪

#### 数据看不懂怎么办？

1. **多种显示格式**：十六进制、ASCII、Unicode
2. **计算器辅助**：进制转换、XOR计算
3. **对比分析**：输入不同数据观察变化

## 🎯 学习成果检验

完成本教程后，你应该能够：

### 基础技能

* ✅ 熟练使用x64dbg或OllyDbg
* ✅ 设置不同类型的断点
* ✅ 查看和理解内存数据
* ✅ 跟踪程序执行流程

### 进阶技能

* ✅ 识别常见的CTF逆向模式
* ✅ 快速定位关键验证逻辑
* ✅ 从内存中提取关键数据
* ✅ 理解简单的加密解密过程

### 解题思维

* ✅ 动态调试与静态分析相结合
* ✅ 从现象推导本质的逆向思维
* ✅ 工具使用与手工分析相结合

## 📚 进一步学习建议

### 推荐练习题目

1. **简单字符串比较题**：练习基本调试技巧
2. **简单加密题**：练习算法逆向
3. **反调试题**：练习绕过保护机制

### 学习资源

* **《逆向工程权威指南》**：系统学习逆向工程
* **CTF Wiki**：在线逆向工程教程
* **各大CTF平台**：大量实战题目

### 工具扩展

* **Ghidra**：NSA开源的逆向分析平台
* **radare2**：命令行逆向分析工具
* **Cheat Engine**：游戏修改和内存分析工具

## 🏆 总结

动态调试是逆向工程中最直观、最实用的技术之一。通过本教程，你学会了：

1. **工具使用**：x64dbg和OllyDbg的基本操作
2. **调试技巧**：断点设置、内存查看、数据跟踪
3. **解题方法**：从动态执行过程中获取关键信息
4. **思维培养**：动态分析的思维模式

记住：**动态调试的核心是观察程序的实际行为，让程序自己告诉你答案**。这种方法特别适合初学者，因为它不需要深入理解复杂的算法细节，而是通过观察和记录来获得结果。

随着经验的积累，你会发现动态调试与静态分析相结合，能够解决更复杂的逆向工程问题。继续练习，你很快就能成为逆向分析的高手！
