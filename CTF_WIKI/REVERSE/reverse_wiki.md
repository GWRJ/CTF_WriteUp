# PlzDebugMe CTF 逆向工程 WriteUp

## 题目信息

* **题目名称**: PlzDebugMe
* **题目类型**: 逆向工程 (Reverse Engineering)
* **难度**: 入门级
* **文件**: 235737\_PlzDebugMe.exe

## 1. 题目分析

### 1.1 初步观察

这是一个典型的入门级逆向工程题目。从题目名称"PlzDebugMe"可以推测，这道题需要我们通过调试或静态分析来找出隐藏的flag。

### 1.2 工具准备

对于逆向工程，我们需要准备以下工具：

* **IDA Pro** 或 **Ghidra**: 静态反汇编分析工具
* **x64dbg** 或 **OllyDbg**: 动态调试工具
* **十六进制编辑器**: 如HxD、010 Editor
* **字符串提取工具**: 如strings命令

## 2. 静态分析过程

### 2.1 使用IDA Pro分析

将exe文件拖入IDA Pro，等待自动分析完成。

#### 寻找main函数

1. 查看函数列表，寻找可能的主函数
2. 找到关键函数 `sub_401697()`，这很可能是主要的验证逻辑

#### 反汇编代码分析

```c
int sub_401697()
{
  int i; // [esp+1Ch] [ebp-4h]
  sub_401860();
  sub_40160C("WeLcome to Reverse World!\n");
  sub_40160C("Length of the flag is 32.\n");
  sub_40160C("Please enter your flag:\n");
  sub_4015D0("%s", byte_415060);
  if ( byte_415060[0] == 102    // 'f'
    && byte_415061 == 108       // 'l'
    && byte_415062 == 97        // 'a'
    && byte_415063 == 103       // 'g'
    && byte_415064 == 123       // '{'
    && byte_41507F == 125 )     // '}'
  {
    sub_401648(123456);
    for ( i = 0; i <= 31; ++i )
    {
      byte_415060[i] = sub_40167D((unsigned __int8)byte_415060[i]);
      if ( byte_415060[i] != byte_410020[i] )
      {
        sub_40160C("Pity! Wrong flag!\n");
        return 0;
      }
    }
    sub_40160C("Congratulations! You get the flag!\n");
    return 0;
  }
  else
  {
    sub_40160C("WRONG\n");
    return 0;
  }
}
```

### 2.2 程序逻辑分析

#### 第一层检查：格式验证

```c
if ( byte_415060[0] == 102    // 'f'
  && byte_415061 == 108       // 'l'
  && byte_415062 == 97        // 'a'
  && byte_415063 == 103       // 'g'
  && byte_415064 == 123       // '{'
  && byte_41507F == 125 )     // '}'
```

**分析要点**：

* 程序首先检查输入是否以 `flag{` 开头
* 检查第31个字符（索引31，因为数组从0开始）是否为 `}`
* 说明flag格式为: `flag{...内容...}`，总长度32位

#### 第二层检查：加密验证

```c
sub_401648(123456);  // 初始化某种算法
for ( i = 0; i <= 31; ++i )
{
  byte_415060[i] = sub_40167D((unsigned __int8)byte_415060[i]);
  if ( byte_415060[i] != byte_410020[i] )  // 与目标数组比较
  {
    // 验证失败
  }
}
```

**分析要点**：

* `sub_401648(123456)` 看起来像是初始化函数，参数123456可能是种子
* `sub_40167D` 是对每个字符进行某种变换
* 变换后的结果与 `byte_410020` 数组进行比较

### 2.3 深入分析关键函数

#### sub\_401648函数分析

```c
int __cdecl sub_401648(int a1)
{
  int result; // eax
  result = a1;
  dword_415080 = a1;  // 将参数存储到全局变量
  return result;
}
```

这个函数很简单，就是把参数123456存储到全局变量 `dword_415080` 中。

#### sub\_40167D函数分析

```c
int __cdecl sub_40167D(unsigned __int8 a1)
{
  return (unsigned __int8)sub_401656() ^ a1;  // XOR加密
}
```

这是一个XOR加密函数，将输入字符与 `sub_401656()` 的返回值进行异或操作。

#### sub\_401656函数分析（关键！）

```c
unsigned int sub_401656()
{
  dword_415080 = 1103515245 * dword_415080 + 12345;
  return HIWORD(dword_415080) & 0x7FFF;
}
```

**重要发现**：

* 这是一个**线性同余生成器 (Linear Congruential Generator, LCG)**
* 公式：`next = (a * seed + c) mod m`
* 这里 a=1103515245, c=12345, m=2^32（32位整数溢出）
* 返回值是高16位的低15位：`(seed >> 16) & 0x7FFF`

### 2.4 获取目标数据

在IDA中查看 `byte_410020` 地址的数据：

```
地址 410020 处的32字节数据：
5B 50 A1 25 84 8E 61 C4 6B BB AE 05 0B C6 3D 42
5A FB C1 C9 4E E9 8D 50 91 87 87 24 AD AF D5 36
```

## 3. 加密算法理解

### 3.1 完整的加密流程

1. **初始化**：设置LCG种子为123456
2. **对每个字符**：
   * 调用LCG生成下一个伪随机数
   * 取随机数的低8位
   * 与字符进行XOR运算
3. **比较**：将加密结果与目标数组比较

### 3.2 LCG算法详解

线性同余生成器是一种常见的伪随机数生成算法：

```
seed[n+1] = (a × seed[n] + c) mod m

其中：
- a = 1103515245 (乘数)
- c = 12345 (增量)  
- m = 2^32 (模数，通过32位整数溢出实现)
- seed[0] = 123456 (初始种子)
```

**为什么这样设计？**

* LCG算法简单，在CTF中经常使用
* 只要知道参数和种子，就能完全重现随机数序列
* 这就给了我们破解的可能性

## 4. 解密方案

### 4.1 解密思路

既然我们知道了：

1. 加密算法（XOR + LCG）
2. LCG的参数 (a=1103515245, c=12345, seed=123456)
3. 加密后的目标数据

那么我们可以：

1. 重现相同的LCG随机数序列
2. 将目标数据与随机数进行XOR，得到原始字符

### 4.2 XOR的性质

XOR运算有一个重要性质：**可逆性**

* 如果 `A XOR B = C`
* 那么 `C XOR B = A`

所以如果我们知道：

* 原文 XOR 随机数 = 密文
* 那么：密文 XOR 随机数 = 原文

### 4.3 Python解密脚本

```python
def lcg_next(seed):
    """线性同余生成器"""
    seed = (seed * 1103515245 + 12345) & 0xFFFFFFFF
    return seed, (seed >> 16) & 0x7FFF

def decrypt_flag():
    # 目标加密数据
    encrypted = [
        0x5B, 0x50, 0xA1, 0x25, 0x84, 0x8E, 0x61, 0xC4,
        0x6B, 0xBB, 0xAE, 0x05, 0x0B, 0xC6, 0x3D, 0x42,
        0x5A, 0xFB, 0xC1, 0xC9, 0x4E, 0xE9, 0x8D, 0x50,
        0x91, 0x87, 0x87, 0x24, 0xAD, 0xAF, 0xD5, 0x36
    ]
  
    seed = 123456
    flag = []
  
    for i in range(32):
        seed, random_val = lcg_next(seed)
        decrypted_char = encrypted[i] ^ (random_val & 0xFF)
        flag.append(chr(decrypted_char))
  
    return ''.join(flag)
```

## 5. 逆向工程技术总结

### 5.1 这道题涉及的知识点

1. **静态分析**：使用反汇编工具分析程序结构
2. **伪随机数生成器**：理解LCG算法原理
3. **XOR加密**：了解异或运算的性质
4. **数据提取**：从程序中提取关键数据
5. **算法逆向**：从加密过程推导解密方法

### 5.2 解题思路总结

1. **理解程序逻辑**：分析main函数，找到验证流程
2. **识别加密算法**：分析关键函数，理解加密方式
3. **提取关键数据**：获取加密参数和目标数据
4. **设计解密方案**：利用算法的可逆性质
5. **编写解密工具**：实现自动化解密

### 5.3 常见的逆向分析模式

#### 字符串比较型

* 直接比较输入与预设字符串
* 解法：直接提取目标字符串

#### 简单变换型

* 对输入进行简单的数学运算（加减乘除、位运算）
* 解法：逆向数学运算

#### 伪随机加密型（本题类型）

* 使用伪随机数生成器进行加密
* 解法：重现随机数序列，逆向加密过程

#### 复杂加密算法型

* 使用标准加密算法（AES、DES等）
* 解法：找到密钥，使用对应解密算法

## 6. 学习建议

### 6.1 对于RE新手

1. **掌握基础工具**：
   * 学会使用IDA Pro/Ghidra进行静态分析
   * 学会使用调试器进行动态分析
2. **理解常见算法**：
   * 各种伪随机数生成器
   * 基础加密算法（XOR、Caesar等）
   * 常见的字符串处理方法
3. **培养逆向思维**：
   * 从结果推导过程
   * 理解程序的执行流程
   * 学会抽象和简化问题

### 6.2 进阶学习路径

1. **汇编语言基础**：理解x86/x64汇编
2. **加密学基础**：了解各种加密算法
3. **反调试技术**：学习如何绕过程序的保护机制
4. **脱壳技术**：处理被加壳保护的程序

### 6.3 实践建议

1. 多做CTF题目，从简单到复杂
2. 阅读优秀的writeup，学习他人的思路
3. 学习使用各种逆向工程工具
4. 关注安全社区，了解最新技术

## 7. 总结

这道 PlzDebugMe 题目虽然标记为"超级简单"，但实际上涉及了逆向工程的多个重要概念：

1. **静态分析技能**：使用IDA Pro分析程序结构
2. **算法识别能力**：识别出LCG伪随机数生成器
3. **密码学基础**：理解XOR加密的可逆性
4. **编程实现**：将分析结果转化为可执行的解密代码

对于逆向工程初学者来说，这是一道很好的入门题目，它展现了逆向分析的完整流程：观察→分析→理解→实现。通过这道题目，可以学习到逆向工程的基本思维模式和常用技术手段。

记住逆向工程的核心：**理解程序想要什么，然后给它想要的**。在这道题中，程序想要的是经过特定算法加密后的字符串，我们通过逆向这个算法，成功找到了原始的flag。
